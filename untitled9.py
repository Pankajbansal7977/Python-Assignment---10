# -*- coding: utf-8 -*-
"""Untitled9.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/131xx3JAGudS_3gXbUWgJD2IYHz5ul_E8
"""

'''
What is the role of the 'else' block in a try-except statement? Provide an example
scenario where it would be useful.
'''

def divide_numbers(a, b):
    try:
        result = a / b
    except ZeroDivisionError:
        print("Error: Division by zero is not allowed.")
    else:
        print(f"The result of {a} / {b} is {result}")

# Example 1: No exception
divide_numbers(10, 2)

# Example 2: Exception
divide_numbers(8, 0)

'''
Can a try-except block be nested inside another try-except block? Explain with an
example.
'''

def complex_operation(a, b):
    try:
        result = a / b
        print("Division result:", result)
    except ZeroDivisionError:
        print("Error: Division by zero")
        result = None

    try:
        square_root = result ** 0.5
        print("Square root of the result:", square_root)
    except TypeError:
        print("Error: Result is not a valid number")
    except ValueError:
        print("Error: Result is negative, cannot compute square root")
    except Exception as e:
        print("An unexpected error occurred:", e)

# Example 1: No exception
complex_operation(9, 3)

complex_operation(5, 0)

complex_operation(4, -4)

'''
How can you create a custom exception class in Python? Provide an example that
demonstrates its usage.
'''

class InsufficientFundsError(Exception):
    """Custom exception for when an account has insufficient funds."""
    def __init__(self, balance, amount):
        self.balance = balance
        self.amount = amount
        super().__init__(f"Insufficient funds: Balance = {balance}, Withdrawal amount = {amount}")

def withdraw_from_account(balance, amount):
    try:
        if amount > balance:
            raise InsufficientFundsError(balance, amount)
        else:
            new_balance = balance - amount
            print(f"Withdrawal successful! New balance: {new_balance}")
    except InsufficientFundsError as e:
        print(e)

# Example 1: Sufficient funds
withdraw_from_account(1000, 500)


# Example 2: Insufficient funds
withdraw_from_account(200, 500)

# What are some common exceptions that are built-in to Python?

'''
SyntaxError: Raised when there is a syntax error in the code.

IndentationError: Raised when there is an issue with the indentation of the code.

NameError: Raised when a local or global name is not found.

TypeError: Raised when an operation or function is applied to an object of inappropriate type.

ValueError: Raised when a function receives an argument of correct type but an inappropriate value.

IndexError: Raised when an index for a sequence is out of range.

KeyError: Raised when a dictionary key is not found.

FileNotFoundError: Raised when a file is not found.

IOError: Raised when an input/output operation fails.

ZeroDivisionError: Raised when division or modulo by zero occurs.

AttributeError: Raised when an attribute reference or assignment fails.

ImportError: Raised when an imported module is not found.

ModuleNotFoundError: A more specific version of ImportError raised when a module is not found.

AssertionError: Raised when an assert statement fails.

RuntimeError: A generic error that is raised when an error occurs at runtime.

StopIteration: Raised when the next() method of an iterator does not have any more items to return.

KeyboardInterrupt: Raised when the user interrupts the program's execution (usually by pressing Ctrl+C).

MemoryError: Raised when an operation runs out of memory.

OverflowError: Raised when an arithmetic operation exceeds the limits of the data type.

RecursionError: Raised when the maximum recursion depth is exceeded.
'''

# What is logging in Python, and why is it important in software development?

'''

Logging in Python refers to the practice of recording information, messages, and events that occur during the execution of a program.
'''
import logging

# Configure logging
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

# Example usage
def divide(a, b):
    try:
        result = a / b
    except ZeroDivisionError:
        logging.error("Attempted division by zero")
        return None
    else:
        logging.info(f"Division result: {result}")
        return result

result = divide(10, 2)

'''
Explain the purpose of log levels in Python logging and provide examples of when
each log level would be appropriate.
'''

'''
Log levels in Python logging are used to categorize log messages based on their severity or importance. Different log levels allow you to control the granularity of information that is recorded in the logs
'''

'''
What are log formatters in Python logging, and how can you customise the log
message format using formatters?
'''

import logging

# Create a custom log formatter
formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')

# Create a console handler and set the formatter
console_handler = logging.StreamHandler()
console_handler.setFormatter(formatter)

# Create a logger and add the console handler
logger = logging.getLogger('custom_logger')
logger.addHandler(console_handler)
logger.setLevel(logging.DEBUG)

# Example usage
logger.debug("This is a debug message")
logger.info("This is an info message")
logger.warning("This is a warning message")
logger.error("This is an error message")
logger.critical("This is a critical message")

'''
How can you set up logging to capture log messages from multiple modules or
classes in a Python application?
'''

# logger_setup.py
import logging

def setup_logger():
    logger = logging.getLogger('my_app')
    logger.setLevel(logging.DEBUG)

    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')

    console_handler = logging.StreamHandler()
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)

    # Add other handlers (file, etc.) as needed

    return logger

# main.py
import logger_setup
import module_a
import module_b

if __name__ == "__main__":
    logger = logger_setup.setup_logger()

    logger.debug("Starting the application")

    module_a.do_something(logger)
    module_b.do_something_else(logger)

    logger.debug("Finishing the application")

# module_a.py
def do_something(logger):
    logger.info("Doing something in Module A")

# module_b.py
def do_something_else(logger):
    logger.warning("Doing something else in Module B")

'''
What is the difference between the logging and print statements in Python? When
should you use logging over print statements in a real-world application?
'''

'''

Both logging and print statements are used in Python to output information, but they serve different purposes and have different implications, especially in more complex and real-world applications.

Logging:

Purpose: Logging is specifically designed for recording information, events, and errors during the execution of a program. It's used for both development/debugging and production monitoring purposes.
Flexibility: Logging provides fine-grained control over the format, level, and destination of log messages. You can configure different log levels (debug, info, warning, error, critical) and direct log output to various places (console, files, external services).
'''
'''
Print Statements:

Purpose: Print statements are used for displaying information to the console during program execution. They are primarily used for debugging and quick inspection of variables' values.
Output: Print statements don't offer the same level of control and formatting options as logging. The output is simple and often lacks additional contextual information.
Visibility: In complex applications, excessive print statements can clutter the console and make it difficult to separate the relevant output from the debugging information.
Debugging: While print statements can help you identify issues, they are not as effective for systematic debugging as logging because they cannot be easily controlled, filtered, or
'''

'''
Write a Python program that logs a message to a file named "app.log" with the
following requirements:
● The log message should be "Hello, World!"
● The log level should be set to "INFO."
● The log file should append new log entries without overwriting previous ones.
'''

import logging

# Configure logging to write to a file
logging.basicConfig(filename='app.log', level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Log the message
logging.info("Hello, World!")
'''
logging.basicConfig is used to configure the logging system. We set the filename to "app.log" using the filename parameter, the log level to "INFO" using the level parameter, and the log message format using the format parameter.
The logging.info function is used to log the "Hello, World!" message with the "INFO" log level. This message will be written to the "app.log" file along with the timestamp and log level.
'''

'''
Create a Python program that logs an error message to the console and a file named
"errors.log" if an exception occurs during the program's execution. The error
message should include the exception type and a timestamp.
'''

import logging

def main():
    try:
        # Your code that might raise an exception
        result = 10 / 0  # This will raise a ZeroDivisionError
    except Exception as e:
        # Configure logging to write to the console and a file
        logging.basicConfig(level=logging.ERROR, format='%(asctime)s - %(levelname)s - %(message)s')

        # Create a file handler for errors.log
        file_handler = logging.FileHandler('errors.log')
        file_handler.setLevel(logging.ERROR)

        # Create a formatter and set it for the file handler
        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
        file_handler.setFormatter(formatter)

        # Add the file handler to the root logger
        logging.getLogger().addHandler(file_handler)

        # Log the error message
        logging.error(f"Exception occurred: {type(e).__name__}")

if __name__ == "__main__":
    main()